#!/bin/bash
# set -e

###bugsinpy-testall reproduces all the bugs for every project
# test ok (reproduced successfully) test fail (unable to reproduce)
# Full setup logs in each $DIR/projects/$project/logs.txt
# output.csv in $OUTPUT
# Filex bug_fixed.txt and bug_buggy.txt are added to each project bug

DIR="/home/user"
OUTPUT="$DIR/projects/output.csv"
# DIR_OF_SCRIPT=$(dirname $0)
# DIR_OF_PROJECT=$(realpath $(dirname $0)/../..)

usage="
       -h
             show this help
       -c
             cleanup $DIR directory
       -p
             specify multiple project:start:end or project:end or project:
             Ex;
             pandas:75:100 (reproduce tests 75 to 100 for pandas)
             black:5 ansible: (only reproduces test 5 for black and all for ansible)
"

case $1 in
 -[h?] | --help)
    echo "Usage: ${0##*/} [ --help ]"
    echo "$usage"
    exit 0;;
 -c)
    read -p "Are you sure? [y/n]" -n 1 -r
    if [[ $REPLY =~ ^[Yy]$ ]]
    then
      rm -rfv "$DIR/projects/*"
    fi
    exit 0;;
 -p)
    projects="${@:2}";;
esac

mkdir -p $DIR/projects

if ! echo $projects | grep -q ":"; then
  projects=$(ls $DIR/BugsInPy/projects)
fi

echo "Reproducing bugs please wait ..."
echo "---------------"

touch $OUTPUT
if ! grep "repo,bugid,version,result" $OUTPUT; then
  echo "repo,bugid,version,result" | tee $OUTPUT
fi

# Cleanup unfinished reproductions
sed -i '/[0-9]$/d' $OUTPUT
# Iterate over the projects
for project in $projects; do

  # Get the number of bugs in the project
  if ! echo $projects | grep -q ":"; then
    start=1
    finish=$(ls $DIR/BugsInPy/projects/$project/bugs | wc -l)
  else
    start=$(echo $project | cut -d ":" -f 2)
    finish=$(echo $project | cut -d ":" -f 3)
    project=$(echo $project | cut -d ":" -f 1)
    if [[ "$start" == "" ]]; then
      finish=$(ls $DIR/BugsInPy/projects/$project/bugs | wc -l)
      start=1
    elif [[ "$finish" == "" ]]; then
      finish=$start
    fi
  fi

  # For each bug, execute the test
  for bug in $(seq $start $finish); do

    BUG_SOURCE_DIR="$DIR/BugsInPy/projects/$project/bugs/$bug"

    if [ -d "$BUG_SOURCE_DIR" ]; then
      # echo $LINENO # debug

      work_dir="$DIR/projects/$project"
      mkdir -p $work_dir
      cd $work_dir

      # Test buggy (0) version
      bugsinpy-checkout -p $project -v 0 -i $bug -w $DIR/projects &>> $work_dir/logs.txt


      ###Required to use conda activate, included in docker continuumio/miniconda3
      . /opt/conda/etc/profile.d/conda.sh &>> $work_dir/logs.txt
      ###Setup proper python version already installed using miniconda
      bug_python_version=$(grep -o "3\..\.." bugsinpy_bug.info)

      ###Add environment
      dos2unix $work_dir/bugsinpy_requirements.txt
      . /opt/conda/etc/profile.d/conda.sh
      bug_python_version=$(grep -o "3\..\.." "$work_dir/bugsinpy_bug.info")
      conda_env_name=$(cat <(echo $bug_python_version) "$work_dir/bugsinpy_requirements.txt" | md5sum | cut -d' ' -f 1)
      if ! conda env list | grep -q "$conda_env_name"; then
        conda create -n $conda_env_name -y python=$bug_python_version &>> $work_dir/logs.txt
      fi

      # TODO: Develop custom fixes for failing libraries
      # if echo $work_dir | grep -q xyz; then
      #   conda install -y -c conda-forge xyz=2.2.5
      # fi

      bugsinpy-compile &>> $work_dir/logs.txt
      bugsinpy-test &> $BUG_SOURCE_DIR/bug_buggy.txt

      # Make sure a failure is detected in buggy version and bug is reproducible
      if grep -q "= ERRORS =" $BUG_SOURCE_DIR/bug_buggy.txt || grep -q ": command not found" $BUG_SOURCE_DIR/bug_buggy.txt ;then
        echo "$project,$bug,buggy,error" | tee -a $OUTPUT
      elif [ -f "bugsinpy_fail.txt" ]; then
        echo "$project,$bug,buggy,fail" | tee -a $OUTPUT
      else
        echo "$project,$bug,buggy,pass" | tee -a $OUTPUT
      fi

      # Test fixed (1) version
      bugsinpy-checkout -p $project -v 1 -i $bug -w $DIR/projects &>> $work_dir/logs.txt
      bugsinpy-compile &>> $work_dir/logs.txt
      bugsinpy-test &> $BUG_SOURCE_DIR/bug_fixed.txt

      # Test execution output and make sure fixed version passes test ok
      if grep -q "= ERRORS =" $BUG_SOURCE_DIR/bug_fixed.txt || grep -q ": command not found" $BUG_SOURCE_DIR/bug_fixed.txt ;then
        echo "$project,$bug,fixed,error" | tee -a $OUTPUT
      elif [ -f "bugsinpy_fail.txt" ]; then
        echo "$project,$bug,fixed,fail" | tee -a $OUTPUT
      else
        echo "$project,$bug,fixed,pass" | tee -a $OUTPUT
      fi
    fi
  done
done

echo "done."
